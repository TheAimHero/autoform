{"version":3,"sources":["../src/datasource/manager.ts","../src/context/FormContext.tsx","../src/hooks/useDataSource.ts","../src/hooks/useFieldRenderer.ts","../src/components/FieldRenderer.tsx","../src/components/AutoForm.tsx","../src/schema/parser.ts","../src/schema/zodGenerator.ts","../src/registry/fieldRegistry.ts","../src/hooks/useAutoForm.ts"],"names":["DEFAULT_STALE_TIME","options","useWatch","useMemo","createContext","useContext","useCallback","jsx","AutoField","AutoFieldArray","Fragment"],"mappings":"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","file":"index.js","sourcesContent":["import { atom, PrimitiveAtom } from 'jotai';\nimport type {\n  DataSourceConfig,\n  DataSourcesConfig,\n  DataSourceState,\n  DataSourceFetchParams,\n  FieldOption,\n} from '../types';\n\n/**\n * Cache entry for data source results\n */\ninterface CacheEntry {\n  data: FieldOption[];\n  timestamp: number;\n  cacheKey: string;\n}\n\n/**\n * Global cache for data source results\n */\nconst dataSourceCache = new Map<string, CacheEntry>();\n\n/**\n * Default stale time (30 seconds)\n */\nconst DEFAULT_STALE_TIME = 30000;\n\n/**\n * Generate a default cache key from params\n */\nfunction generateDefaultCacheKey(sourceKey: string, params: DataSourceFetchParams): string {\n  const deps = params.dependencies ? JSON.stringify(params.dependencies) : '';\n  const query = params.searchQuery || '';\n  return `${sourceKey}:${deps}:${query}`;\n}\n\n/**\n * Check if a cache entry is stale\n */\nfunction isCacheStale(entry: CacheEntry, staleTime: number): boolean {\n  return Date.now() - entry.timestamp > staleTime;\n}\n\n/**\n * Create a data source atom for managing async data\n */\nexport function createDataSourceAtom<TData, TValue>(\n  sourceKey: string,\n  config: DataSourceConfig<TData, TValue>\n): PrimitiveAtom<DataSourceState<TValue>> {\n  // Base state atom\n  const stateAtom = atom<DataSourceState<TValue>>({\n    options: [],\n    isLoading: false,\n    error: null,\n    lastFetched: null,\n  });\n\n  // Store config and sourceKey for later use\n  (stateAtom as any).__config = config;\n  (stateAtom as any).__sourceKey = sourceKey;\n  (stateAtom as any).__generateCacheKey = (params: DataSourceFetchParams) => {\n    const cacheKeyFn =\n      config.cacheKey || ((p: DataSourceFetchParams) => generateDefaultCacheKey(sourceKey, p));\n    return cacheKeyFn(params);\n  };\n  (stateAtom as any).__staleTime = config.staleTime ?? DEFAULT_STALE_TIME;\n\n  return stateAtom;\n}\n\n/**\n * Fetch data for a data source atom\n */\nexport async function fetchDataSourceAtom<TData, TValue>(\n  sourceKey: string,\n  config: DataSourceConfig<TData, TValue>,\n  params: DataSourceFetchParams,\n  setState: (state: DataSourceState<TValue>) => void,\n  getState: () => DataSourceState<TValue>\n): Promise<void> {\n  // Generate cache key\n  const cacheKeyFn =\n    config.cacheKey || ((p: DataSourceFetchParams) => generateDefaultCacheKey(sourceKey, p));\n  const cacheKey = cacheKeyFn(params);\n  const staleTime = config.staleTime ?? DEFAULT_STALE_TIME;\n\n  // Check cache\n  const cached = dataSourceCache.get(cacheKey);\n  if (cached && !isCacheStale(cached, staleTime)) {\n    setState({\n      options: cached.data as FieldOption<TValue>[],\n      isLoading: false,\n      error: null,\n      lastFetched: cached.timestamp,\n    });\n    return;\n  }\n\n  // Set loading state\n  setState({\n    ...getState(),\n    isLoading: true,\n    error: null,\n  });\n\n  try {\n    const data = await config.fetch(params);\n    const options = config.transform(data);\n    const timestamp = Date.now();\n\n    // Update cache\n    dataSourceCache.set(cacheKey, {\n      data: options,\n      timestamp,\n      cacheKey,\n    });\n\n    setState({\n      options,\n      isLoading: false,\n      error: null,\n      lastFetched: timestamp,\n    });\n  } catch (error) {\n    // Ignore abort errors\n    if (error instanceof Error && error.name === 'AbortError') {\n      return;\n    }\n\n    const errorObj = error instanceof Error ? error : new Error(String(error));\n\n    if (config.onError) {\n      config.onError(errorObj);\n    }\n\n    setState({\n      ...getState(),\n      isLoading: false,\n      error: errorObj,\n    });\n  }\n}\n\n/**\n * Data source manager for handling multiple data sources\n */\nexport class DataSourceManager {\n  private configs: DataSourcesConfig;\n  private atoms: Map<string, PrimitiveAtom<DataSourceState>>;\n\n  constructor(configs: DataSourcesConfig = {}) {\n    this.configs = configs;\n    this.atoms = new Map();\n  }\n\n  /**\n   * Get or create an atom for a data source\n   */\n  getAtom(sourceKey: string): PrimitiveAtom<DataSourceState> | undefined {\n    const config = this.configs[sourceKey];\n    if (!config) {\n      return undefined;\n    }\n\n    if (!this.atoms.has(sourceKey)) {\n      this.atoms.set(sourceKey, createDataSourceAtom(sourceKey, config));\n    }\n\n    return this.atoms.get(sourceKey);\n  }\n\n  /**\n   * Get the configuration for a data source\n   */\n  getConfig(sourceKey: string): DataSourceConfig | undefined {\n    return this.configs[sourceKey];\n  }\n\n  /**\n   * Check if a data source exists\n   */\n  has(sourceKey: string): boolean {\n    return sourceKey in this.configs;\n  }\n\n  /**\n   * Add a new data source configuration\n   */\n  addSource(sourceKey: string, config: DataSourceConfig): void {\n    this.configs[sourceKey] = config;\n  }\n\n  /**\n   * Remove a data source\n   */\n  removeSource(sourceKey: string): void {\n    delete this.configs[sourceKey];\n    this.atoms.delete(sourceKey);\n  }\n\n  /**\n   * Clear all cached data\n   */\n  clearCache(): void {\n    dataSourceCache.clear();\n  }\n\n  /**\n   * Clear cache for a specific source\n   */\n  clearSourceCache(sourceKey: string): void {\n    for (const [key] of dataSourceCache) {\n      if (key.startsWith(`${sourceKey}:`)) {\n        dataSourceCache.delete(key);\n      }\n    }\n  }\n}\n\n/**\n * Create a data source manager instance\n */\nexport function createDataSourceManager(configs: DataSourcesConfig = {}): DataSourceManager {\n  return new DataSourceManager(configs);\n}\n\n/**\n * Clear all data source cache\n */\nexport function clearDataSourceCache(): void {\n  dataSourceCache.clear();\n}\n","import { createContext, useContext, ReactNode } from 'react';\nimport type { UseFormReturn, FieldValues } from 'react-hook-form';\nimport type { AutoFormSchema, DataSourcesConfig } from '../types';\nimport type { FieldRegistry } from '../registry';\nimport type { DataSourceManager } from '../datasource';\n\n/**\n * Context value for AutoForm\n */\nexport interface AutoFormContextValue<TFieldValues extends FieldValues = FieldValues> {\n  /**\n   * React Hook Form instance\n   */\n  form: UseFormReturn<TFieldValues>;\n\n  /**\n   * The form schema\n   */\n  schema: AutoFormSchema;\n\n  /**\n   * Field registry for component lookup\n   */\n  registry: FieldRegistry;\n\n  /**\n   * Data source manager for async fields\n   */\n  dataSourceManager: DataSourceManager;\n\n  /**\n   * Data sources configuration\n   */\n  dataSources: DataSourcesConfig;\n\n  /**\n   * Whether the form is in a loading state\n   */\n  isLoading?: boolean;\n\n  /**\n   * Whether the form is disabled\n   */\n  isDisabled?: boolean;\n\n  /**\n   * Whether all fields are read-only\n   */\n  isReadOnly?: boolean;\n}\n\n/**\n * AutoForm context\n */\nconst AutoFormContext = createContext<AutoFormContextValue | null>(null);\n\n/**\n * Provider props\n */\nexport interface AutoFormProviderProps<TFieldValues extends FieldValues = FieldValues> {\n  value: AutoFormContextValue<TFieldValues>;\n  children: ReactNode;\n}\n\n/**\n * AutoForm context provider\n */\nexport function AutoFormProvider<TFieldValues extends FieldValues = FieldValues>({\n  value,\n  children,\n}: AutoFormProviderProps<TFieldValues>) {\n  return (\n    <AutoFormContext.Provider value={value as AutoFormContextValue}>\n      {children}\n    </AutoFormContext.Provider>\n  );\n}\n\n/**\n * Hook to access AutoForm context\n * @throws Error if used outside of AutoFormProvider\n */\nexport function useAutoFormContext<\n  TFieldValues extends FieldValues = FieldValues,\n>(): AutoFormContextValue<TFieldValues> {\n  const context = useContext(AutoFormContext);\n\n  if (!context) {\n    throw new Error(\n      'useAutoFormContext must be used within an AutoFormProvider. ' +\n        'Make sure your component is wrapped with <AutoForm> or <AutoFormProvider>.'\n    );\n  }\n\n  return context as AutoFormContextValue<TFieldValues>;\n}\n\n/**\n * Hook to check if we're inside AutoForm context\n */\nexport function useIsInsideAutoForm(): boolean {\n  const context = useContext(AutoFormContext);\n  return context !== null;\n}\n","import { useState, useEffect, useRef, useCallback, useMemo } from 'react';\nimport { useWatch } from 'react-hook-form';\nimport type { Control } from 'react-hook-form';\nimport type {\n  DataSourceConfig,\n  UseDataSourceResult,\n  FieldOption,\n  DataSourceFetchParams,\n} from '../types';\n\n/**\n * Cache entry\n */\ninterface CacheEntry {\n  data: FieldOption[];\n  timestamp: number;\n}\n\n/**\n * Global cache\n */\nconst cache = new Map<string, CacheEntry>();\n\n/**\n * Track in-flight requests to prevent duplicate fetches\n */\nconst inFlightRequests = new Map<string, Promise<FieldOption[]>>();\n\n/**\n * Default stale time\n */\nconst DEFAULT_STALE_TIME = 30000;\n\n/**\n * Default debounce time\n */\nconst DEFAULT_DEBOUNCE_MS = 300;\n\n/**\n * Options for useDataSource hook\n */\nexport interface UseDataSourceOptions {\n  /**\n   * Data source configuration\n   */\n  config: DataSourceConfig;\n\n  /**\n   * Unique key for this data source\n   */\n  sourceKey: string;\n\n  /**\n   * Field names this data source depends on\n   */\n  dependsOn?: string[];\n\n  /**\n   * React Hook Form control (for watching dependencies)\n   */\n  control?: Control<any>;\n\n  /**\n   * Whether to fetch on mount\n   * @default true\n   */\n  fetchOnMount?: boolean;\n\n  /**\n   * Whether the data source is enabled\n   * @default true\n   */\n  enabled?: boolean;\n}\n\n/**\n * Generate cache key\n */\nfunction generateCacheKey(sourceKey: string, params: DataSourceFetchParams): string {\n  const deps = params.dependencies ? JSON.stringify(params.dependencies) : '';\n  const query = params.searchQuery || '';\n  return `${sourceKey}:${deps}:${query}`;\n}\n\n/**\n * Hook for managing async data sources\n */\nexport function useDataSource<TValue = unknown>(\n  options: UseDataSourceOptions\n): UseDataSourceResult<TValue> {\n  const {\n    config,\n    sourceKey,\n    dependsOn = [],\n    control,\n    fetchOnMount = true,\n    enabled = true,\n  } = options;\n\n  const [state, setState] = useState<{\n    options: FieldOption<TValue>[];\n    isLoading: boolean;\n    error: Error | null;\n  }>({\n    options: [],\n    isLoading: false,\n    error: null,\n  });\n\n  // Store config in a ref to avoid recreating fetchData on config changes\n  const configRef = useRef(config);\n  configRef.current = config;\n\n  // Watch dependent fields\n  const dependencyValues = useWatch({\n    control,\n    name: dependsOn,\n    disabled: !control || dependsOn.length === 0,\n  });\n\n  // Memoize dependencies object to prevent unnecessary re-renders\n  const dependenciesKey = useMemo(() => {\n    if (dependsOn.length === 0) return '';\n    const deps: Record<string, unknown> = {};\n    dependsOn.forEach((name, index) => {\n      deps[name] = Array.isArray(dependencyValues) ? dependencyValues[index] : dependencyValues;\n    });\n    return JSON.stringify(deps);\n  }, [dependsOn, dependencyValues]);\n\n  // Abort controller ref\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  // Debounce timer ref\n  const debounceTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n  // Search query ref\n  const searchQueryRef = useRef<string>('');\n\n  // Track if component is mounted\n  const isMountedRef = useRef(true);\n\n  // Track the last fetch key to prevent duplicate concurrent fetches\n  const lastFetchKeyRef = useRef<string | null>(null);\n\n  // Track if initial fetch is in progress\n  const isFetchingRef = useRef(false);\n\n  // Fetch data function - uses refs for stability\n  const fetchData = useCallback(\n    async (searchQuery?: string) => {\n      if (!enabled) return;\n\n      const currentConfig = configRef.current;\n      const staleTime = currentConfig.staleTime ?? DEFAULT_STALE_TIME;\n      const dependencies = dependenciesKey ? JSON.parse(dependenciesKey) : undefined;\n\n      const params: DataSourceFetchParams = {\n        dependencies,\n        searchQuery,\n      };\n\n      // Check custom cache key\n      const cacheKeyFn = currentConfig.cacheKey || ((p) => generateCacheKey(sourceKey, p));\n      const cacheKey = cacheKeyFn(params);\n\n      // Check cache first\n      const cached = cache.get(cacheKey);\n      if (cached && Date.now() - cached.timestamp < staleTime) {\n        if (isMountedRef.current) {\n          setState({\n            options: cached.data as FieldOption<TValue>[],\n            isLoading: false,\n            error: null,\n          });\n        }\n        return;\n      }\n\n      // Check if there's already an in-flight request for this key\n      const existingRequest = inFlightRequests.get(cacheKey);\n      if (existingRequest) {\n        try {\n          const options = await existingRequest;\n          if (isMountedRef.current) {\n            setState({\n              options: options as FieldOption<TValue>[],\n              isLoading: false,\n              error: null,\n            });\n          }\n        } catch {\n          // Error handled by the original request\n        }\n        return;\n      }\n\n      // Prevent duplicate fetch for same key\n      if (lastFetchKeyRef.current === cacheKey) {\n        return;\n      }\n      lastFetchKeyRef.current = cacheKey;\n      isFetchingRef.current = true;\n\n      // Cancel previous request\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n      abortControllerRef.current = new AbortController();\n\n      if (isMountedRef.current) {\n        setState((prev) => ({ ...prev, isLoading: true, error: null }));\n      }\n\n      // Create the fetch promise\n      const fetchPromise = (async () => {\n        const data = await currentConfig.fetch({\n          ...params,\n          signal: abortControllerRef.current!.signal,\n        });\n        return currentConfig.transform(data) as FieldOption[];\n      })();\n\n      // Track the in-flight request\n      inFlightRequests.set(cacheKey, fetchPromise);\n\n      try {\n        const options = await fetchPromise;\n\n        // Update cache\n        cache.set(cacheKey, {\n          data: options,\n          timestamp: Date.now(),\n        });\n\n        if (isMountedRef.current) {\n          setState({\n            options: options as FieldOption<TValue>[],\n            isLoading: false,\n            error: null,\n          });\n        }\n      } catch (error) {\n        // Ignore abort errors\n        if (error instanceof Error && error.name === 'AbortError') {\n          return;\n        }\n\n        const errorObj = error instanceof Error ? error : new Error(String(error));\n\n        if (currentConfig.onError) {\n          currentConfig.onError(errorObj);\n        }\n\n        if (isMountedRef.current) {\n          setState((prev) => ({\n            ...prev,\n            isLoading: false,\n            error: errorObj,\n          }));\n        }\n      } finally {\n        // Remove from in-flight requests\n        inFlightRequests.delete(cacheKey);\n        // Clear the last fetch key so future fetches can proceed\n        if (lastFetchKeyRef.current === cacheKey) {\n          lastFetchKeyRef.current = null;\n        }\n        isFetchingRef.current = false;\n      }\n    },\n    [sourceKey, dependenciesKey, enabled]\n  );\n\n  // Debounced search handler\n  const onSearch = useCallback(\n    (query: string) => {\n      searchQueryRef.current = query;\n\n      const debounceMs = configRef.current.debounceMs ?? DEFAULT_DEBOUNCE_MS;\n\n      if (debounceTimerRef.current) {\n        clearTimeout(debounceTimerRef.current);\n      }\n\n      debounceTimerRef.current = setTimeout(() => {\n        fetchData(query);\n      }, debounceMs);\n    },\n    [fetchData]\n  );\n\n  // Refetch function\n  const refetch = useCallback(() => {\n    // Clear the last fetch key to allow refetch\n    lastFetchKeyRef.current = null;\n    fetchData(searchQueryRef.current);\n  }, [fetchData]);\n\n  // Track previous dependencies key for change detection\n  const prevDependenciesKeyRef = useRef<string>('');\n\n  // Fetch on mount and when dependencies change\n  useEffect(() => {\n    isMountedRef.current = true;\n\n    const shouldFetchOnMount = fetchOnMount && enabled && !isFetchingRef.current;\n    const dependenciesChanged = dependenciesKey !== prevDependenciesKeyRef.current;\n\n    if (shouldFetchOnMount || (dependenciesChanged && dependsOn.length > 0)) {\n      prevDependenciesKeyRef.current = dependenciesKey;\n      // Clear the last fetch key to allow fetch\n      lastFetchKeyRef.current = null;\n      fetchData();\n    }\n\n    return () => {\n      isMountedRef.current = false;\n      if (abortControllerRef.current) {\n        abortControllerRef.current.abort();\n      }\n      if (debounceTimerRef.current) {\n        clearTimeout(debounceTimerRef.current);\n      }\n    };\n  }, [fetchOnMount, enabled, fetchData, dependenciesKey, dependsOn.length]);\n\n  return {\n    options: state.options,\n    isLoading: state.isLoading,\n    error: state.error,\n    refetch,\n    onSearch,\n  };\n}\n\n/**\n * Clear all data source cache\n */\nexport function clearCache(): void {\n  cache.clear();\n}\n\n/**\n * Clear cache for a specific source\n */\nexport function clearSourceCache(sourceKey: string): void {\n  for (const [key] of cache) {\n    if (key.startsWith(`${sourceKey}:`)) {\n      cache.delete(key);\n    }\n  }\n}\n","import { useMemo } from \"react\";\nimport { useController, useWatch } from \"react-hook-form\";\nimport type { Control } from \"react-hook-form\";\nimport type {\n  FieldDefinition,\n  FieldComponentProps,\n  FieldState,\n  FieldOption,\n} from \"../types\";\nimport type { FieldRegistry } from \"../registry\";\nimport { useDataSource } from \"./useDataSource\";\nimport type { DataSourcesConfig } from \"../types\";\n\n/**\n * Options for useFieldRenderer hook\n */\nexport interface UseFieldRendererOptions {\n  /**\n   * Field definition from schema\n   */\n  field: FieldDefinition;\n\n  /**\n   * React Hook Form control\n   */\n  control: Control<any>;\n\n  /**\n   * Field registry\n   */\n  registry: FieldRegistry;\n\n  /**\n   * Data sources configuration\n   */\n  dataSources: DataSourcesConfig;\n\n  /**\n   * Base path for nested fields\n   */\n  basePath?: string;\n\n  /**\n   * Whether the field is disabled\n   */\n  isDisabled?: boolean;\n\n  /**\n   * Whether the field is read-only\n   */\n  isReadOnly?: boolean;\n}\n\n/**\n * Result of useFieldRenderer hook\n */\nexport interface UseFieldRendererResult {\n  /**\n   * Props to pass to the field component\n   */\n  fieldProps: FieldComponentProps;\n\n  /**\n   * The component to render\n   */\n  Component: React.ComponentType<FieldComponentProps> | undefined;\n\n  /**\n   * Whether the field should be rendered (based on conditions)\n   */\n  shouldRender: boolean;\n\n  /**\n   * Full field path\n   */\n  fieldPath: string;\n}\n\n/**\n * Evaluate a condition\n */\nfunction evaluateCondition(\n  condition: FieldDefinition[\"condition\"],\n  formValues: Record<string, unknown>,\n): boolean {\n  if (!condition) return true;\n\n  const { when, operator, value } = condition;\n  const fieldValue = getNestedValue(formValues, when);\n\n  switch (operator) {\n    case \"eq\":\n      return fieldValue === value;\n    case \"neq\":\n      return fieldValue !== value;\n    case \"gt\":\n      return (\n        typeof fieldValue === \"number\" &&\n        typeof value === \"number\" &&\n        fieldValue > value\n      );\n    case \"gte\":\n      return (\n        typeof fieldValue === \"number\" &&\n        typeof value === \"number\" &&\n        fieldValue >= value\n      );\n    case \"lt\":\n      return (\n        typeof fieldValue === \"number\" &&\n        typeof value === \"number\" &&\n        fieldValue < value\n      );\n    case \"lte\":\n      return (\n        typeof fieldValue === \"number\" &&\n        typeof value === \"number\" &&\n        fieldValue <= value\n      );\n    case \"in\":\n      return Array.isArray(value) && value.includes(fieldValue);\n    case \"notIn\":\n      return Array.isArray(value) && !value.includes(fieldValue);\n    case \"exists\":\n      return (\n        fieldValue !== undefined && fieldValue !== null && fieldValue !== \"\"\n      );\n    case \"notExists\":\n      return (\n        fieldValue === undefined || fieldValue === null || fieldValue === \"\"\n      );\n    default:\n      return true;\n  }\n}\n\n/**\n * Get nested value from object by path\n */\nfunction getNestedValue(obj: Record<string, unknown>, path: string): unknown {\n  return path.split(\".\").reduce((acc, key) => {\n    if (acc && typeof acc === \"object\" && key in acc) {\n      return (acc as Record<string, unknown>)[key];\n    }\n    return undefined;\n  }, obj as unknown);\n}\n\n/**\n * Hook for preparing field rendering\n */\nexport function useFieldRenderer(\n  hookOptions: UseFieldRendererOptions,\n): UseFieldRendererResult {\n  const {\n    field,\n    control,\n    registry,\n    dataSources,\n    basePath = \"\",\n    isDisabled = false,\n    isReadOnly = false,\n  } = hookOptions;\n\n  // Compute full field path\n  const fieldPath = basePath ? `${basePath}.${field.name}` : field.name;\n\n  // Get the field component\n  const Component = registry.fields[field.type];\n\n  // Use controller for field state\n  const { field: controllerField, fieldState } = useController({\n    name: fieldPath,\n    control,\n    defaultValue: field.defaultValue,\n  });\n\n  // Watch all form values for condition evaluation\n  const formValues = useWatch({ control });\n\n  // Evaluate condition\n  const shouldRender = useMemo(\n    () =>\n      evaluateCondition(field.condition, formValues as Record<string, unknown>),\n    [field.condition, formValues],\n  );\n\n  // Get data source config if needed\n  const dataSourceConfig = field.dataSourceKey\n    ? dataSources[field.dataSourceKey]\n    : undefined;\n\n  // Use data source if configured\n  const dataSourceResult = useDataSource({\n    config: dataSourceConfig || {\n      fetch: async () => [],\n      transform: (data) => data as FieldOption[],\n    },\n    sourceKey: field.dataSourceKey || fieldPath,\n    dependsOn: field.dependsOn,\n    control,\n    fetchOnMount: !!dataSourceConfig,\n    enabled: !!dataSourceConfig && shouldRender,\n  });\n\n  // Merge static options with async options\n  const options: FieldOption[] = useMemo(() => {\n    if (dataSourceConfig) {\n      return dataSourceResult.options;\n    }\n    return field.options || [];\n  }, [field.options, dataSourceConfig, dataSourceResult.options]);\n\n  // Build field state\n  const state: FieldState = useMemo(\n    () => ({\n      isLoading: dataSourceResult.isLoading,\n      isDisabled: isDisabled || field.disabled || false,\n      isRequired: !!field.validation?.required,\n      isTouched: fieldState.isTouched,\n      isDirty: fieldState.isDirty,\n      isReadOnly: isReadOnly || field.readOnly || false,\n    }),\n    [\n      dataSourceResult.isLoading,\n      isDisabled,\n      field.disabled,\n      field.validation?.required,\n      fieldState.isTouched,\n      fieldState.isDirty,\n      isReadOnly,\n      field.readOnly,\n    ],\n  );\n\n  // Build props for the component\n  const fieldProps: FieldComponentProps = useMemo(\n    () => ({\n      name: fieldPath,\n      value: controllerField.value,\n      onChange: controllerField.onChange,\n      onBlur: controllerField.onBlur,\n      inputRef: controllerField.ref,\n      label: field.label,\n      placeholder: field.placeholder,\n      description: field.description,\n      options,\n      state,\n      error: fieldState.error,\n      onSearch: dataSourceConfig ? dataSourceResult.onSearch : undefined,\n      fieldProps: field.fieldProps,\n      className: field.className,\n    }),\n    [\n      fieldPath,\n      controllerField,\n      field.label,\n      field.placeholder,\n      field.description,\n      field.fieldProps,\n      field.className,\n      options,\n      state,\n      fieldState.error,\n      dataSourceConfig,\n      dataSourceResult.onSearch,\n    ],\n  );\n\n  return {\n    fieldProps,\n    Component,\n    shouldRender,\n    fieldPath,\n  };\n}\n","import {\n  memo,\n  useCallback,\n  useMemo,\n  createContext,\n  useContext,\n  ReactNode,\n} from \"react\";\nimport { useFieldArray } from \"react-hook-form\";\nimport type { Control } from \"react-hook-form\";\nimport type { FieldDefinition, DataSourcesConfig, FieldState } from \"../types\";\nimport type { FieldRegistry } from \"../registry\";\nimport { useFieldRenderer } from \"../hooks/useFieldRenderer\";\n\n/**\n * Props for AutoField component\n */\nexport interface AutoFieldProps {\n  field: FieldDefinition;\n  control: Control<any>;\n  registry: FieldRegistry;\n  dataSources: DataSourcesConfig;\n  basePath?: string;\n  isDisabled?: boolean;\n  isReadOnly?: boolean;\n}\n\n/**\n * Context for field rendering to avoid circular imports\n */\nconst FieldRendererContext = createContext<{\n  renderField: (props: AutoFieldProps) => ReactNode;\n} | null>(null);\n\n/**\n * Get default value for a field type\n */\nfunction getDefaultForType(type?: string): unknown {\n  switch (type) {\n    case \"number\":\n      return 0;\n    case \"checkbox\":\n    case \"switch\":\n      return false;\n    case \"multiselect\":\n      return [];\n    default:\n      return \"\";\n  }\n}\n\n/**\n * Internal array field component\n */\nfunction ArrayFieldInternal({\n  field,\n  control,\n  registry,\n  dataSources,\n  basePath,\n  isDisabled,\n  isReadOnly,\n}: AutoFieldProps) {\n  const context = useContext(FieldRendererContext);\n  const fieldPath = basePath ? `${basePath}.${field.name}` : field.name;\n\n  const { fields, append, remove, move } = useFieldArray({\n    control,\n    name: fieldPath,\n  });\n\n  const ArrayWrapper = registry.arrayField;\n\n  const state: FieldState = useMemo(\n    () => ({\n      isLoading: false,\n      isDisabled: isDisabled || field.disabled || false,\n      isRequired: !!field.validation?.required,\n      isTouched: false,\n      isDirty: false,\n      isReadOnly: isReadOnly || field.readOnly || false,\n    }),\n    [\n      isDisabled,\n      field.disabled,\n      field.validation?.required,\n      isReadOnly,\n      field.readOnly,\n    ],\n  );\n\n  const handleAppend = useCallback(\n    (value?: unknown) => {\n      if (field.maxItems !== undefined && fields.length >= field.maxItems) {\n        return;\n      }\n\n      if (field.itemType === \"object\" && field.itemFields) {\n        const defaultItem: Record<string, unknown> = {};\n        for (const itemField of field.itemFields) {\n          if (itemField.defaultValue !== undefined) {\n            defaultItem[itemField.name] = itemField.defaultValue;\n          }\n        }\n        append(value ?? defaultItem);\n      } else {\n        append(value ?? getDefaultForType(field.itemType));\n      }\n    },\n    [append, field.itemType, field.itemFields, field.maxItems, fields.length],\n  );\n\n  const handleRemove = useCallback(\n    (index: number) => {\n      if (field.minItems !== undefined && fields.length <= field.minItems) {\n        return;\n      }\n      remove(index);\n    },\n    [remove, field.minItems, fields.length],\n  );\n\n  const handleMove = useCallback(\n    (fromIndex: number, toIndex: number) => {\n      move(fromIndex, toIndex);\n    },\n    [move],\n  );\n\n  const renderItem = useCallback(\n    (index: number) => {\n      const itemPath = `${fieldPath}.${index}`;\n\n      if (field.itemType === \"object\" && field.itemFields) {\n        return (\n          <>\n            {field.itemFields.map((itemField) =>\n              context?.renderField({\n                key: itemField.name,\n                field: itemField,\n                control,\n                registry,\n                dataSources,\n                basePath: itemPath,\n                isDisabled: isDisabled || field.disabled,\n                isReadOnly: isReadOnly || field.readOnly,\n              } as AutoFieldProps & { key: string }),\n            )}\n          </>\n        );\n      }\n\n      if (field.itemDefinition) {\n        return context?.renderField({\n          field: {\n            ...field.itemDefinition,\n            name: String(index),\n          } as FieldDefinition,\n          control,\n          registry,\n          dataSources,\n          basePath: fieldPath,\n          isDisabled: isDisabled || field.disabled,\n          isReadOnly: isReadOnly || field.readOnly,\n        });\n      }\n\n      const primitiveField: FieldDefinition = {\n        name: String(index),\n        type: (field.itemType as FieldDefinition[\"type\"]) || \"text\",\n        label: `Item ${index + 1}`,\n      };\n\n      return context?.renderField({\n        field: primitiveField,\n        control,\n        registry,\n        dataSources,\n        basePath: fieldPath,\n        isDisabled: isDisabled || field.disabled,\n        isReadOnly: isReadOnly || field.readOnly,\n      });\n    },\n    [\n      fieldPath,\n      field.itemType,\n      field.itemFields,\n      field.itemDefinition,\n      field.disabled,\n      field.readOnly,\n      control,\n      registry,\n      dataSources,\n      isDisabled,\n      isReadOnly,\n      context,\n    ],\n  );\n\n  if (ArrayWrapper) {\n    return (\n      <ArrayWrapper\n        name={fieldPath}\n        label={field.label}\n        description={field.description}\n        fields={fields.map((f, i) => ({ id: f.id, index: i }))}\n        renderItem={renderItem}\n        onAppend={handleAppend}\n        onRemove={handleRemove}\n        onMove={handleMove}\n        state={state}\n        minItems={field.minItems}\n        maxItems={field.maxItems}\n        fieldProps={field.fieldProps}\n        className={field.className}\n      />\n    );\n  }\n\n  return (\n    <div className={field.className}>\n      {field.label && <label>{field.label}</label>}\n      {field.description && <p>{field.description}</p>}\n      <div>\n        {fields.map((f, index) => (\n          <div\n            key={f.id}\n            style={{ display: \"flex\", gap: \"8px\", marginBottom: \"8px\" }}\n          >\n            <div style={{ flex: 1 }}>{renderItem(index)}</div>\n            {!state.isDisabled && !state.isReadOnly && (\n              <button\n                type=\"button\"\n                onClick={() => handleRemove(index)}\n                disabled={\n                  field.minItems !== undefined &&\n                  fields.length <= field.minItems\n                }\n              >\n                Remove\n              </button>\n            )}\n          </div>\n        ))}\n      </div>\n      {!state.isDisabled && !state.isReadOnly && (\n        <button\n          type=\"button\"\n          onClick={() => handleAppend()}\n          disabled={\n            field.maxItems !== undefined && fields.length >= field.maxItems\n          }\n        >\n          Add Item\n        </button>\n      )}\n    </div>\n  );\n}\n\n/**\n * Internal field component\n */\nfunction FieldInternal(props: AutoFieldProps) {\n  const {\n    field,\n    control,\n    registry,\n    dataSources,\n    basePath,\n    isDisabled,\n    isReadOnly,\n  } = props;\n  const context = useContext(FieldRendererContext);\n\n  const { fieldProps, Component, shouldRender, fieldPath } = useFieldRenderer({\n    field,\n    control,\n    registry,\n    dataSources,\n    basePath,\n    isDisabled,\n    isReadOnly,\n  });\n\n  if (!shouldRender) {\n    return null;\n  }\n\n  if (field.type === \"object\" && field.fields) {\n    const ObjectWrapper = registry.objectField;\n\n    const nestedFields = (\n      <>\n        {field.fields.map((nestedField) =>\n          context?.renderField({\n            key: nestedField.name,\n            field: nestedField,\n            control,\n            registry,\n            dataSources,\n            basePath: fieldPath,\n            isDisabled: isDisabled || field.disabled,\n            isReadOnly: isReadOnly || field.readOnly,\n          } as AutoFieldProps & { key: string }),\n        )}\n      </>\n    );\n\n    if (ObjectWrapper) {\n      return (\n        <ObjectWrapper\n          name={fieldPath}\n          label={field.label}\n          description={field.description}\n          state={fieldProps.state}\n          error={fieldProps.error}\n          fieldProps={field.fieldProps}\n          className={field.className}\n        >\n          {nestedFields}\n        </ObjectWrapper>\n      );\n    }\n\n    return <div className={field.className}>{nestedFields}</div>;\n  }\n\n  if (field.type === \"array\") {\n    return <ArrayFieldInternal {...props} />;\n  }\n\n  if (!Component) {\n    return null;\n  }\n\n  return <Component {...fieldProps} />;\n}\n\nconst MemoizedField = memo(FieldInternal);\n\n/**\n * Provider and entry point for field rendering\n */\nexport function FieldRendererProvider({ children }: { children: ReactNode }) {\n  const renderField = useCallback(\n    (props: AutoFieldProps & { key?: string }) => {\n      const { key, ...fieldProps } = props;\n      return (\n        <MemoizedField key={key || fieldProps.field.name} {...fieldProps} />\n      );\n    },\n    [],\n  );\n\n  return (\n    <FieldRendererContext.Provider value={{ renderField }}>\n      {children}\n    </FieldRendererContext.Provider>\n  );\n}\n\n/**\n * AutoField component - renders a single field\n */\nexport const AutoField = memo(function AutoField(props: AutoFieldProps) {\n  return <MemoizedField {...props} />;\n});\n\nAutoField.displayName = \"AutoField\";\n\n/**\n * AutoFieldArray component - renders an array field\n */\nexport const AutoFieldArray = memo(function AutoFieldArray(\n  props: AutoFieldProps,\n) {\n  return <ArrayFieldInternal {...props} />;\n});\n\nAutoFieldArray.displayName = \"AutoFieldArray\";\n","import { useMemo, ReactNode } from 'react';\nimport type {\n  UseFormReturn,\n  FieldValues,\n  SubmitHandler,\n  SubmitErrorHandler,\n} from 'react-hook-form';\nimport type { AutoFormSchema, DataSourcesConfig } from '../types';\nimport type { FieldRegistry } from '../registry';\nimport { createDataSourceManager } from '../datasource';\nimport { AutoFormProvider, type AutoFormContextValue } from '../context';\nimport { AutoField, FieldRendererProvider } from './FieldRenderer';\n\n/**\n * Props for AutoForm component\n */\nexport interface AutoFormProps<TFieldValues extends FieldValues = FieldValues> {\n  /**\n   * Form schema definition\n   */\n  schema: AutoFormSchema;\n\n  /**\n   * React Hook Form instance (from useForm or useAutoForm)\n   */\n  form: UseFormReturn<TFieldValues>;\n\n  /**\n   * Field registry mapping types to components\n   */\n  registry: FieldRegistry;\n\n  /**\n   * Data sources configuration for async fields\n   */\n  dataSources?: DataSourcesConfig;\n\n  /**\n   * Submit handler\n   */\n  onSubmit?: SubmitHandler<TFieldValues>;\n\n  /**\n   * Error handler for submission errors\n   */\n  onError?: SubmitErrorHandler<TFieldValues>;\n\n  /**\n   * Whether the form is in loading state\n   */\n  isLoading?: boolean;\n\n  /**\n   * Whether the form is disabled\n   */\n  isDisabled?: boolean;\n\n  /**\n   * Whether all fields are read-only\n   */\n  isReadOnly?: boolean;\n\n  /**\n   * CSS class name for the form\n   */\n  className?: string;\n\n  /**\n   * Render prop for custom form layout\n   * If provided, schema fields are passed to this function\n   */\n  children?: ReactNode | ((props: AutoFormRenderProps) => ReactNode);\n}\n\n/**\n * Props passed to render function\n */\nexport interface AutoFormRenderProps {\n  /**\n   * Render all fields in schema order\n   */\n  fields: ReactNode;\n\n  /**\n   * Render a specific field by name\n   */\n  Field: React.ComponentType<{ name: string }>;\n\n  /**\n   * Form state\n   */\n  formState: UseFormReturn['formState'];\n\n  /**\n   * Whether form is submitting\n   */\n  isSubmitting: boolean;\n\n  /**\n   * Whether form is valid\n   */\n  isValid: boolean;\n}\n\n/**\n * Main AutoForm component\n */\nexport function AutoForm<TFieldValues extends FieldValues = FieldValues>({\n  schema,\n  form,\n  registry,\n  dataSources = {},\n  onSubmit,\n  onError,\n  isLoading = false,\n  isDisabled = false,\n  isReadOnly = false,\n  className,\n  children,\n}: AutoFormProps<TFieldValues>) {\n  // Create data source manager\n  const dataSourceManager = useMemo(() => createDataSourceManager(dataSources), [dataSources]);\n\n  // Create context value\n  const contextValue: AutoFormContextValue<TFieldValues> = useMemo(\n    () => ({\n      form,\n      schema,\n      registry,\n      dataSourceManager,\n      dataSources,\n      isLoading,\n      isDisabled,\n      isReadOnly,\n    }),\n    [form, schema, registry, dataSourceManager, dataSources, isLoading, isDisabled, isReadOnly]\n  );\n\n  // Handle submit\n  const handleSubmit = form.handleSubmit(onSubmit || (() => {}), onError);\n\n  // Render all fields\n  const renderedFields = useMemo(\n    () => (\n      <>\n        {schema.fields.map((field) => (\n          <AutoField\n            key={field.name}\n            field={field}\n            control={form.control}\n            registry={registry}\n            dataSources={dataSources}\n            isDisabled={isDisabled}\n            isReadOnly={isReadOnly}\n          />\n        ))}\n      </>\n    ),\n    [schema.fields, form.control, registry, dataSources, isDisabled, isReadOnly]\n  );\n\n  // Field component for rendering specific fields\n  const FieldByName = useMemo(() => {\n    const Component = ({ name }: { name: string }) => {\n      const field = schema.fields.find((f) => f.name === name);\n      if (!field) {\n        return null;\n      }\n      return (\n        <AutoField\n          field={field}\n          control={form.control}\n          registry={registry}\n          dataSources={dataSources}\n          isDisabled={isDisabled}\n          isReadOnly={isReadOnly}\n        />\n      );\n    };\n    Component.displayName = 'AutoFormField';\n    return Component;\n  }, [schema.fields, form.control, registry, dataSources, isDisabled, isReadOnly]);\n\n  // Render props for custom layout\n  const renderProps: AutoFormRenderProps = {\n    fields: renderedFields,\n    Field: FieldByName,\n    formState: form.formState,\n    isSubmitting: form.formState.isSubmitting,\n    isValid: form.formState.isValid,\n  };\n\n  // Form content\n  const formContent =\n    typeof children === 'function' ? children(renderProps) : (children ?? renderedFields);\n\n  // Use custom form wrapper if provided\n  const FormWrapper = registry.formWrapper;\n\n  if (FormWrapper) {\n    return (\n      <AutoFormProvider value={contextValue}>\n        <FieldRendererProvider>\n          <FormWrapper onSubmit={handleSubmit} className={className}>\n            {formContent}\n          </FormWrapper>\n        </FieldRendererProvider>\n      </AutoFormProvider>\n    );\n  }\n\n  // Default form element\n  return (\n    <AutoFormProvider value={contextValue}>\n      <FieldRendererProvider>\n        <form onSubmit={handleSubmit} className={className}>\n          {formContent}\n        </form>\n      </FieldRendererProvider>\n    </AutoFormProvider>\n  );\n}\n\nAutoForm.displayName = 'AutoForm';\n\n/**\n * HOC to create a typed AutoForm component\n */\nexport function createTypedAutoForm<TFieldValues extends FieldValues>() {\n  return AutoForm as React.ComponentType<AutoFormProps<TFieldValues>>;\n}\n","import type { AutoFormSchema, FieldDefinition, FieldType } from '../types/schema';\n\n/**\n * Valid field types\n */\nconst VALID_FIELD_TYPES: FieldType[] = [\n  'text',\n  'email',\n  'password',\n  'number',\n  'textarea',\n  'select',\n  'multiselect',\n  'autocomplete',\n  'checkbox',\n  'radio',\n  'switch',\n  'date',\n  'datetime',\n  'time',\n  'file',\n  'object',\n  'array',\n  'hidden',\n];\n\n/**\n * Schema validation error\n */\nexport class SchemaValidationError extends Error {\n  constructor(\n    message: string,\n    public path: string,\n    public details?: unknown\n  ) {\n    super(`Schema validation error at \"${path}\": ${message}`);\n    this.name = 'SchemaValidationError';\n  }\n}\n\n/**\n * Result of schema parsing\n */\nexport interface ParsedSchema {\n  schema: AutoFormSchema;\n  fieldPaths: string[];\n  hasAsyncFields: boolean;\n  hasConditionalFields: boolean;\n  hasArrayFields: boolean;\n  hasNestedObjects: boolean;\n}\n\n/**\n * Validate a single field definition\n */\nfunction validateField(field: FieldDefinition, path: string): void {\n  // Name is required\n  if (!field.name || typeof field.name !== 'string') {\n    throw new SchemaValidationError('Field must have a valid \"name\" string', path);\n  }\n\n  // Type is required and must be valid\n  if (!field.type || !VALID_FIELD_TYPES.includes(field.type)) {\n    throw new SchemaValidationError(\n      `Field must have a valid \"type\". Got \"${field.type}\", expected one of: ${VALID_FIELD_TYPES.join(', ')}`,\n      `${path}.${field.name}`\n    );\n  }\n\n  // Object type must have fields\n  if (field.type === 'object') {\n    if (!field.fields || !Array.isArray(field.fields) || field.fields.length === 0) {\n      throw new SchemaValidationError(\n        'Object type field must have a non-empty \"fields\" array',\n        `${path}.${field.name}`\n      );\n    }\n    // Recursively validate nested fields\n    for (const nestedField of field.fields) {\n      validateField(nestedField, `${path}.${field.name}`);\n    }\n  }\n\n  // Array type validation\n  if (field.type === 'array') {\n    if (!field.itemType) {\n      throw new SchemaValidationError(\n        'Array type field must have \"itemType\" defined',\n        `${path}.${field.name}`\n      );\n    }\n\n    // If itemType is 'object', must have itemFields\n    if (field.itemType === 'object') {\n      if (!field.itemFields || !Array.isArray(field.itemFields) || field.itemFields.length === 0) {\n        throw new SchemaValidationError(\n          'Array field with itemType \"object\" must have a non-empty \"itemFields\" array',\n          `${path}.${field.name}`\n        );\n      }\n      // Validate item fields\n      for (const itemField of field.itemFields) {\n        validateField(itemField, `${path}.${field.name}[]`);\n      }\n    }\n  }\n\n  // Select/radio/multiselect must have options or dataSourceKey\n  if (['select', 'multiselect', 'radio'].includes(field.type)) {\n    if (!field.options && !field.dataSourceKey) {\n      throw new SchemaValidationError(\n        `Field type \"${field.type}\" must have either \"options\" array or \"dataSourceKey\"`,\n        `${path}.${field.name}`\n      );\n    }\n  }\n\n  // Validate condition if present\n  if (field.condition) {\n    if (!field.condition.when || typeof field.condition.when !== 'string') {\n      throw new SchemaValidationError(\n        'Condition must have a valid \"when\" field name',\n        `${path}.${field.name}.condition`\n      );\n    }\n    if (!field.condition.operator) {\n      throw new SchemaValidationError(\n        'Condition must have an \"operator\"',\n        `${path}.${field.name}.condition`\n      );\n    }\n  }\n\n  // Validate dependsOn if present\n  if (field.dependsOn) {\n    if (!Array.isArray(field.dependsOn)) {\n      throw new SchemaValidationError(\n        '\"dependsOn\" must be an array of field names',\n        `${path}.${field.name}`\n      );\n    }\n  }\n}\n\n/**\n * Collect all field paths from schema\n */\nfunction collectFieldPaths(fields: FieldDefinition[], basePath: string = ''): string[] {\n  const paths: string[] = [];\n\n  for (const field of fields) {\n    const fieldPath = basePath ? `${basePath}.${field.name}` : field.name;\n    paths.push(fieldPath);\n\n    if (field.type === 'object' && field.fields) {\n      paths.push(...collectFieldPaths(field.fields, fieldPath));\n    }\n\n    // For arrays, we don't add nested paths since they're dynamic\n  }\n\n  return paths;\n}\n\n/**\n * Check if schema has async fields (dataSourceKey)\n */\nfunction hasAsyncFields(fields: FieldDefinition[]): boolean {\n  for (const field of fields) {\n    if (field.dataSourceKey) return true;\n    if (field.type === 'object' && field.fields && hasAsyncFields(field.fields)) return true;\n    if (field.type === 'array' && field.itemFields && hasAsyncFields(field.itemFields)) return true;\n  }\n  return false;\n}\n\n/**\n * Check if schema has conditional fields\n */\nfunction hasConditionalFields(fields: FieldDefinition[]): boolean {\n  for (const field of fields) {\n    if (field.condition) return true;\n    if (field.type === 'object' && field.fields && hasConditionalFields(field.fields)) return true;\n    if (field.type === 'array' && field.itemFields && hasConditionalFields(field.itemFields))\n      return true;\n  }\n  return false;\n}\n\n/**\n * Check if schema has array fields\n */\nfunction hasArrayFields(fields: FieldDefinition[]): boolean {\n  for (const field of fields) {\n    if (field.type === 'array') return true;\n    if (field.type === 'object' && field.fields && hasArrayFields(field.fields)) return true;\n  }\n  return false;\n}\n\n/**\n * Check if schema has nested objects\n */\nfunction hasNestedObjects(fields: FieldDefinition[]): boolean {\n  for (const field of fields) {\n    if (field.type === 'object') return true;\n  }\n  return false;\n}\n\n/**\n * Parse and validate an AutoForm schema\n */\nexport function parseSchema(schema: AutoFormSchema): ParsedSchema {\n  // Basic structure validation\n  if (!schema || typeof schema !== 'object') {\n    throw new SchemaValidationError('Schema must be an object', 'root');\n  }\n\n  if (!schema.fields || !Array.isArray(schema.fields)) {\n    throw new SchemaValidationError('Schema must have a \"fields\" array', 'root');\n  }\n\n  if (schema.fields.length === 0) {\n    throw new SchemaValidationError('Schema must have at least one field', 'root.fields');\n  }\n\n  // Validate each field\n  for (const field of schema.fields) {\n    validateField(field, 'root');\n  }\n\n  // Check for duplicate field names at root level\n  const rootNames = new Set<string>();\n  for (const field of schema.fields) {\n    if (rootNames.has(field.name)) {\n      throw new SchemaValidationError(`Duplicate field name \"${field.name}\" at root level`, 'root');\n    }\n    rootNames.add(field.name);\n  }\n\n  return {\n    schema,\n    fieldPaths: collectFieldPaths(schema.fields),\n    hasAsyncFields: hasAsyncFields(schema.fields),\n    hasConditionalFields: hasConditionalFields(schema.fields),\n    hasArrayFields: hasArrayFields(schema.fields),\n    hasNestedObjects: hasNestedObjects(schema.fields),\n  };\n}\n\n/**\n * Get a field definition by path\n */\nexport function getFieldByPath(schema: AutoFormSchema, path: string): FieldDefinition | undefined {\n  const parts = path.split('.');\n  let fields = schema.fields;\n  let field: FieldDefinition | undefined;\n\n  for (let i = 0; i < parts.length; i++) {\n    const part = parts[i];\n\n    // Handle array index notation (e.g., \"items.0.name\")\n    if (/^\\d+$/.test(part)) {\n      // This is an array index, skip to next part\n      continue;\n    }\n\n    field = fields.find((f) => f.name === part);\n    if (!field) return undefined;\n\n    if (i < parts.length - 1) {\n      // Need to go deeper\n      if (field.type === 'object' && field.fields) {\n        fields = field.fields;\n      } else if (field.type === 'array' && field.itemFields) {\n        fields = field.itemFields;\n      } else {\n        return undefined;\n      }\n    }\n  }\n\n  return field;\n}\n\n/**\n * Get default values from schema\n */\nexport function getDefaultValues(schema: AutoFormSchema): Record<string, unknown> {\n  const defaults: Record<string, unknown> = {};\n\n  function processFields(fields: FieldDefinition[], target: Record<string, unknown>) {\n    for (const field of fields) {\n      if (field.defaultValue !== undefined) {\n        target[field.name] = field.defaultValue;\n      } else if (field.type === 'object' && field.fields) {\n        const nestedDefaults: Record<string, unknown> = {};\n        processFields(field.fields, nestedDefaults);\n        if (Object.keys(nestedDefaults).length > 0) {\n          target[field.name] = nestedDefaults;\n        }\n      } else if (field.type === 'array') {\n        target[field.name] = [];\n      } else if (field.type === 'checkbox' || field.type === 'switch') {\n        target[field.name] = false;\n      }\n    }\n  }\n\n  processFields(schema.fields, defaults);\n  return defaults;\n}\n","import { z, ZodTypeAny, ZodObject } from 'zod';\nimport type { AutoFormSchema, FieldDefinition, ValidationRules } from '../types/schema';\n\n/**\n * Options for Zod schema generation\n */\nexport interface ZodSchemaOptions {\n  /**\n   * Custom validation functions referenced by key in schema\n   */\n  customValidators?: Record<string, (value: unknown) => boolean | string>;\n\n  /**\n   * Whether to make all fields optional by default\n   * @default false\n   */\n  allOptional?: boolean;\n}\n\n/**\n * Apply validation rules to a Zod schema\n */\nfunction applyValidationRules(\n  schema: ZodTypeAny,\n  rules: ValidationRules | undefined,\n  fieldType: string,\n  options: ZodSchemaOptions\n): ZodTypeAny {\n  if (!rules) return schema;\n\n  let result = schema;\n\n  // Required is handled at the field level, not here\n  // Min/max for numbers\n  if (fieldType === 'number') {\n    if (rules.min !== undefined) {\n      const min =\n        typeof rules.min === 'object' ? rules.min : { value: rules.min, message: undefined };\n      result = (result as z.ZodNumber).min(min.value, min.message);\n    }\n    if (rules.max !== undefined) {\n      const max =\n        typeof rules.max === 'object' ? rules.max : { value: rules.max, message: undefined };\n      result = (result as z.ZodNumber).max(max.value, max.message);\n    }\n  }\n\n  // String validations\n  if (typeof (result as any).min === 'function' && fieldType !== 'number') {\n    if (rules.minLength !== undefined) {\n      const minLength =\n        typeof rules.minLength === 'object'\n          ? rules.minLength\n          : { value: rules.minLength, message: undefined };\n      result = (result as z.ZodString).min(minLength.value, minLength.message);\n    }\n    if (rules.maxLength !== undefined) {\n      const maxLength =\n        typeof rules.maxLength === 'object'\n          ? rules.maxLength\n          : { value: rules.maxLength, message: undefined };\n      result = (result as z.ZodString).max(maxLength.value, maxLength.message);\n    }\n    if (rules.email) {\n      const message = typeof rules.email === 'string' ? rules.email : undefined;\n      result = (result as z.ZodString).email(message);\n    }\n    if (rules.url) {\n      const message = typeof rules.url === 'string' ? rules.url : undefined;\n      result = (result as z.ZodString).url(message);\n    }\n    if (rules.uuid) {\n      const message = typeof rules.uuid === 'string' ? rules.uuid : undefined;\n      result = (result as z.ZodString).uuid(message);\n    }\n    if (rules.regex) {\n      const flags = rules.regex.flags || '';\n      const regex = new RegExp(rules.regex.pattern, flags);\n      result = (result as z.ZodString).regex(regex, rules.regex.message);\n    }\n    if (rules.pattern) {\n      const pattern =\n        typeof rules.pattern === 'object'\n          ? rules.pattern\n          : { value: rules.pattern, message: undefined };\n      result = (result as z.ZodString).regex(new RegExp(pattern.value), pattern.message);\n    }\n  }\n\n  // Custom validation\n  if (rules.custom && options.customValidators?.[rules.custom]) {\n    const validator = options.customValidators[rules.custom];\n    result = result.refine(\n      (val) => {\n        const validationResult = validator(val);\n        return validationResult === true;\n      },\n      (val) => {\n        const validationResult = validator(val);\n        return {\n          message: typeof validationResult === 'string' ? validationResult : 'Validation failed',\n        };\n      }\n    );\n  }\n\n  return result;\n}\n\n/**\n * Generate a Zod schema for a single field\n */\nfunction generateFieldSchema(field: FieldDefinition, options: ZodSchemaOptions): ZodTypeAny {\n  let schema: ZodTypeAny;\n\n  switch (field.type) {\n    case 'text':\n    case 'email':\n    case 'password':\n    case 'textarea':\n    case 'hidden':\n      schema = z.string();\n      break;\n\n    case 'number':\n      schema = z.number();\n      break;\n\n    case 'checkbox':\n    case 'switch':\n      schema = z.boolean();\n      break;\n\n    case 'date':\n    case 'datetime':\n    case 'time':\n      // Accept both Date objects and ISO strings\n      schema = z.union([z.date(), z.string()]);\n      break;\n\n    case 'select':\n    case 'radio':\n    case 'autocomplete':\n      // For select fields, we accept any value since options can be dynamic\n      // Runtime validation should check against actual options\n      schema = z.any();\n      break;\n\n    case 'multiselect':\n      schema = z.array(z.any());\n      break;\n\n    case 'file':\n      // File can be File object or null\n      schema = z.any();\n      break;\n\n    case 'object':\n      if (field.fields) {\n        const shape: Record<string, ZodTypeAny> = {};\n        for (const nestedField of field.fields) {\n          shape[nestedField.name] = generateFieldSchema(nestedField, options);\n        }\n        schema = z.object(shape);\n      } else {\n        schema = z.record(z.any());\n      }\n      break;\n\n    case 'array':\n      if (field.itemType === 'object' && field.itemFields) {\n        const itemShape: Record<string, ZodTypeAny> = {};\n        for (const itemField of field.itemFields) {\n          itemShape[itemField.name] = generateFieldSchema(itemField, options);\n        }\n        let arraySchema = z.array(z.object(itemShape));\n\n        if (field.minItems !== undefined) {\n          arraySchema = arraySchema.min(field.minItems);\n        }\n        if (field.maxItems !== undefined) {\n          arraySchema = arraySchema.max(field.maxItems);\n        }\n        schema = arraySchema;\n      } else {\n        // Primitive array\n        let itemSchema: ZodTypeAny;\n        switch (field.itemType) {\n          case 'number':\n            itemSchema = z.number();\n            break;\n          case 'checkbox':\n            itemSchema = z.boolean();\n            break;\n          default:\n            itemSchema = z.string();\n        }\n\n        let arraySchema = z.array(itemSchema);\n        if (field.minItems !== undefined) {\n          arraySchema = arraySchema.min(field.minItems);\n        }\n        if (field.maxItems !== undefined) {\n          arraySchema = arraySchema.max(field.maxItems);\n        }\n        schema = arraySchema;\n      }\n      break;\n\n    default:\n      schema = z.any();\n  }\n\n  // Apply validation rules\n  schema = applyValidationRules(schema, field.validation, field.type, options);\n\n  // Handle required/optional\n  const isRequired = field.validation?.required;\n  if (!isRequired || options.allOptional) {\n    // For strings, also allow empty string\n    if (\n      field.type === 'text' ||\n      field.type === 'email' ||\n      field.type === 'password' ||\n      field.type === 'textarea'\n    ) {\n      schema = schema.optional().or(z.literal(''));\n    } else {\n      schema = schema.optional();\n    }\n  } else if (typeof isRequired === 'string') {\n    // Custom required message - use refine\n    const baseSchema = schema;\n    schema = z.any().refine(\n      (val) => {\n        if (val === undefined || val === null) return false;\n        if (typeof val === 'string' && val.trim() === '') return false;\n        if (Array.isArray(val) && val.length === 0) return false;\n        // Validate against base schema\n        const result = baseSchema.safeParse(val);\n        return result.success;\n      },\n      { message: isRequired }\n    );\n  }\n\n  return schema;\n}\n\n/**\n * Generate a Zod schema from an AutoForm schema\n */\nexport function generateZodSchema(\n  formSchema: AutoFormSchema,\n  options: ZodSchemaOptions = {}\n): ZodObject<Record<string, ZodTypeAny>> {\n  const shape: Record<string, ZodTypeAny> = {};\n\n  for (const field of formSchema.fields) {\n    shape[field.name] = generateFieldSchema(field, options);\n  }\n\n  return z.object(shape);\n}\n\n/**\n * Create a partial Zod schema (all fields optional)\n */\nexport function generatePartialZodSchema(\n  formSchema: AutoFormSchema,\n  options: ZodSchemaOptions = {}\n): ZodObject<Record<string, ZodTypeAny>> {\n  return generateZodSchema(formSchema, { ...options, allOptional: true });\n}\n","import type {\n  FieldType,\n  FieldComponent,\n  ArrayFieldComponent,\n  ObjectFieldComponent,\n  FormWrapperComponent,\n} from '../types';\n\n/**\n * Registry of field components mapped by field type\n */\nexport interface FieldRegistry {\n  /**\n   * Field components by type\n   */\n  fields: Partial<Record<FieldType, FieldComponent>>;\n\n  /**\n   * Array field wrapper component\n   */\n  arrayField?: ArrayFieldComponent;\n\n  /**\n   * Object field wrapper component\n   */\n  objectField?: ObjectFieldComponent;\n\n  /**\n   * Form wrapper component\n   */\n  formWrapper?: FormWrapperComponent;\n}\n\n/**\n * Configuration for creating a field registry\n */\nexport interface FieldRegistryConfig {\n  /**\n   * Map of field types to components\n   */\n  fields?: Partial<Record<FieldType, FieldComponent>>;\n\n  /**\n   * Array field wrapper\n   */\n  arrayField?: ArrayFieldComponent;\n\n  /**\n   * Object field wrapper\n   */\n  objectField?: ObjectFieldComponent;\n\n  /**\n   * Form wrapper\n   */\n  formWrapper?: FormWrapperComponent;\n}\n\n/**\n * Create a field registry with the given components\n */\nexport function createFieldRegistry(config: FieldRegistryConfig = {}): FieldRegistry {\n  return {\n    fields: config.fields || {},\n    arrayField: config.arrayField,\n    objectField: config.objectField,\n    formWrapper: config.formWrapper,\n  };\n}\n\n/**\n * Merge two registries, with the second taking precedence\n */\nexport function mergeRegistries(\n  base: FieldRegistry,\n  override: Partial<FieldRegistry>\n): FieldRegistry {\n  return {\n    fields: { ...base.fields, ...override.fields },\n    arrayField: override.arrayField ?? base.arrayField,\n    objectField: override.objectField ?? base.objectField,\n    formWrapper: override.formWrapper ?? base.formWrapper,\n  };\n}\n\n/**\n * Get a field component from the registry\n */\nexport function getFieldComponent(\n  registry: FieldRegistry,\n  fieldType: FieldType\n): FieldComponent | undefined {\n  return registry.fields[fieldType];\n}\n\n/**\n * Check if a registry has a component for a field type\n */\nexport function hasFieldComponent(registry: FieldRegistry, fieldType: FieldType): boolean {\n  return fieldType in registry.fields && registry.fields[fieldType] !== undefined;\n}\n\n/**\n * Get all registered field types\n */\nexport function getRegisteredFieldTypes(registry: FieldRegistry): FieldType[] {\n  return Object.keys(registry.fields).filter(\n    (key) => registry.fields[key as FieldType] !== undefined\n  ) as FieldType[];\n}\n\n/**\n * Validate that a registry has all required components for a schema\n */\nexport function validateRegistryForSchema(\n  registry: FieldRegistry,\n  fieldTypes: FieldType[],\n  options: { hasArrayFields?: boolean; hasNestedObjects?: boolean } = {}\n): { valid: boolean; missing: string[] } {\n  const missing: string[] = [];\n\n  // Check field types\n  for (const type of fieldTypes) {\n    if (!hasFieldComponent(registry, type) && type !== 'object' && type !== 'array') {\n      missing.push(`fields.${type}`);\n    }\n  }\n\n  // Check array field wrapper if needed\n  if (options.hasArrayFields && !registry.arrayField) {\n    missing.push('arrayField');\n  }\n\n  // Check object field wrapper if needed\n  if (options.hasNestedObjects && !registry.objectField) {\n    missing.push('objectField');\n  }\n\n  return {\n    valid: missing.length === 0,\n    missing,\n  };\n}\n","import { useMemo } from 'react';\nimport { useForm, UseFormReturn, UseFormProps, FieldValues } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport type { AutoFormSchema } from '../types';\nimport { generateZodSchema, type ZodSchemaOptions } from '../schema/zodGenerator';\nimport { getDefaultValues } from '../schema/parser';\n\n/**\n * Options for useAutoForm hook\n */\nexport interface UseAutoFormOptions<TFieldValues extends FieldValues = FieldValues> extends Omit<\n  UseFormProps<TFieldValues>,\n  'resolver' | 'defaultValues'\n> {\n  /**\n   * The form schema\n   */\n  schema: AutoFormSchema;\n\n  /**\n   * Default values (merged with schema defaults)\n   */\n  defaultValues?: Partial<TFieldValues>;\n\n  /**\n   * Zod schema generation options\n   */\n  zodOptions?: ZodSchemaOptions;\n}\n\n/**\n * Result of useAutoForm hook\n */\nexport interface UseAutoFormResult<TFieldValues extends FieldValues = FieldValues> {\n  /**\n   * React Hook Form instance\n   */\n  form: UseFormReturn<TFieldValues>;\n\n  /**\n   * Generated Zod schema\n   */\n  zodSchema: ReturnType<typeof generateZodSchema>;\n}\n\n/**\n * Hook that sets up react-hook-form with auto-generated Zod schema\n */\nexport function useAutoForm<TFieldValues extends FieldValues = FieldValues>(\n  options: UseAutoFormOptions<TFieldValues>\n): UseAutoFormResult<TFieldValues> {\n  const { schema, defaultValues, zodOptions, ...formOptions } = options;\n\n  // Generate Zod schema\n  const zodSchema = useMemo(() => generateZodSchema(schema, zodOptions), [schema, zodOptions]);\n\n  // Get default values from schema and merge with provided defaults\n  const schemaDefaults = useMemo(() => getDefaultValues(schema), [schema]);\n  const mergedDefaults = useMemo(\n    () =>\n      ({\n        ...schemaDefaults,\n        ...defaultValues,\n      }) as TFieldValues,\n    [schemaDefaults, defaultValues]\n  );\n\n  // Create form instance\n  const form = useForm<TFieldValues>({\n    ...formOptions,\n    resolver: zodResolver(zodSchema),\n    defaultValues: mergedDefaults as any,\n  });\n\n  return {\n    form,\n    zodSchema,\n  };\n}\n"]}